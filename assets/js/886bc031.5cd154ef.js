"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[7450],{366:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var i=e(74848),o=e(28453);const s={title:"Calling the ammo.js API",sidebar_position:6},a=void 0,r={id:"user-manual/physics/calling-ammo",title:"Calling the ammo.js API",description:"The PlayCanvas integration with ammo.js does not expose the full capability of the ammo.js API. However, it is possible to call the ammo.js API directly from your PlayCanvas scripts.",source:"@site/docs/user-manual/physics/calling-ammo.md",sourceDirName:"user-manual/physics",slug:"/user-manual/physics/calling-ammo",permalink:"/user-manual/physics/calling-ammo",draft:!1,unlisted:!1,editUrl:"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/physics/calling-ammo.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Calling the ammo.js API",sidebar_position:6},sidebar:"userManualSidebar",previous:{title:"Ray Casting",permalink:"/user-manual/physics/ray-casting"},next:{title:"Updating ammo.js",permalink:"/user-manual/physics/physics-migration"}},l={},c=[{value:"Joint Constraints",id:"joint-constraints",level:2},{value:"Continuous Collision Detection",id:"continuous-collision-detection",level:2}];function d(t){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"The PlayCanvas integration with ammo.js does not expose the full capability of the ammo.js API. However, it is possible to call the ammo.js API directly from your PlayCanvas scripts."}),"\n",(0,i.jsxs)(n.p,{children:["PlayCanvas currently uses ",(0,i.jsx)(n.a,{href:"https://github.com/kripken/ammo.js/commit/dcab07bf0e7f2b4b64c01dc45da846344c8f50be",children:"this build"})," of ammo.js. The API exposed by this build can be found ",(0,i.jsx)(n.a,{href:"https://github.com/kripken/ammo.js/blob/dcab07bf0e7f2b4b64c01dc45da846344c8f50be/ammo.idl",children:"here"}),". Although there is no official documentation for ammo.js, you can refer to the ",(0,i.jsx)(n.a,{href:"https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf",children:"Bullet Physics User Guide"})," to learn more."]}),"\n",(0,i.jsx)(n.h2,{id:"joint-constraints",children:"Joint Constraints"}),"\n",(0,i.jsx)(n.p,{children:"There are currently no PlayCanvas components which implement physics constraints (sometimes known as physics joints). However, it is easy to leverage the ammo.js API to create scripts that implement constraints."}),"\n",(0,i.jsx)(n.p,{children:"Here is the script for a point-to-point constraint (essentially a ball and socket joint):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var PointToPointConstraint = pc.createScript('pointToPointConstraint');\n\nPointToPointConstraint.attributes.add('pivotA', {\n    title: 'Pivot',\n    description: 'Position of the constraint in the local space of this entity.',\n    type: 'vec3',\n    default: [0, 0, 0]\n});\nPointToPointConstraint.attributes.add('entityB', {\n    title: 'Connected Entity',\n    description: 'Optional second entity',\n    type: 'entity'\n});\nPointToPointConstraint.attributes.add('pivotB', {\n    title: 'Connected Pivot',\n    description: 'Position of the constraint in the local space of entity B (if specified).',\n    type: 'vec3',\n    default: [0, 0, 0]\n});\nPointToPointConstraint.attributes.add('breakingThreshold', {\n    title: 'Break Threshold',\n    description: 'Maximum breaking impulse threshold required to break the constraint.',\n    type: 'number',\n    default: 3.4e+38\n});\nPointToPointConstraint.attributes.add('enableCollision', {\n    title: 'Enable Collision',\n    description: 'Enable collision between linked rigid bodies.',\n    type: 'boolean',\n    default: true\n});\nPointToPointConstraint.attributes.add('debugRender', {\n    title: 'Debug Render',\n    description: 'Enable to render a representation of the constraint.',\n    type: 'boolean',\n    default: false\n});\nPointToPointConstraint.attributes.add('debugColor', {\n    title: 'Debug Color',\n    description: 'The color of the debug rendering of the constraint.',\n    type: 'rgb',\n    default: [1, 0, 0]\n});\n\n// initialize code called once per entity\nPointToPointConstraint.prototype.initialize = function() {\n    this.createConstraint();\n\n    this.on('attr', function(name, value, prev) {\n        // If any constraint properties change, recreate the constraint\n        if (name === 'pivotA' || name === 'entityB' || name === 'pivotB') {\n            this.createConstraint();\n        } else if (name === 'breakingThreshold') {\n            this.constraint.setBreakingImpulseThreshold(this.breakingThreshold);\n            this.activate();\n        }\n    });\n    this.on('enable', function () {\n        this.createConstraint();\n    });\n    this.on('disable', function () {\n        this.destroyConstraint();\n    });\n    this.on('destroy', function () {\n        this.destroyConstraint();\n    });\n};\n\nPointToPointConstraint.prototype.createConstraint = function() {\n    if (this.constraint) {\n        this.destroyConstraint();\n    }\n\n    var bodyA = this.entity.rigidbody.body;\n    var pivotA = new Ammo.btVector3(this.pivotA.x, this.pivotA.y, this.pivotA.z);\n    if (this.entityB && this.entityB.rigidbody) {\n        var bodyB = this.entityB.rigidbody.body;\n        var pivotB = new Ammo.btVector3(this.pivotB.x, this.pivotB.y, this.pivotB.z);\n        this.constraint = new Ammo.btPoint2PointConstraint(bodyA, bodyB, pivotA, pivotB);\n    } else {\n        this.constraint = new Ammo.btPoint2PointConstraint(bodyA, pivotA);\n    }\n\n    var dynamicsWorld = this.app.systems.rigidbody.dynamicsWorld;\n    dynamicsWorld.addConstraint(this.constraint, !this.enableCollision);\n\n    this.activate();\n};\n\nPointToPointConstraint.prototype.destroyConstraint = function() {\n    if (this.constraint) {\n        var dynamicsWorld = this.app.systems.rigidbody.dynamicsWorld;\n        dynamicsWorld.removeConstraint(this.constraint);\n        Ammo.destroy(this.constraint);\n        this.constraint = null;\n    }\n};\n\nPointToPointConstraint.prototype.activate = function() {\n    this.entity.rigidbody.activate();\n    if (this.entityB) {\n        this.entityB.rigidbody.activate();\n    }\n};\n\n// update code called every frame\nPointToPointConstraint.prototype.update = function(dt) {\n    if (this.debugRender) {\n        // Note that it's generally bad to allocate new objects in an update function\n        // but this is just for debug rendering and will normally be disabled\n        var tempVecA = new pc.Vec3();\n        this.entity.getWorldTransform().transformPoint(this.pivotA, tempVecA);\n        this.app.renderLine(this.entity.getPosition(), tempVecA, this.debugColor);\n        if (this.entityB) {\n            this.app.renderLine(this.entityB.getPosition(), tempVecA, this.debugColor);\n        }\n    }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can find a project that implements all of the constraint types from ammo.js ",(0,i.jsx)(n.a,{href:"https://playcanvas.com/project/618829/overview/physics-constraints",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"continuous-collision-detection",children:"Continuous Collision Detection"}),"\n",(0,i.jsx)(n.p,{children:"Sometimes, you might find that fast moving rigid bodies in your simulations pass through one another. To overcome this, ammo.js provides a concept called Continuous Collision Detection (or CCD for short). This enables additional checks for collisions by sweeping a sphere volume between the previous and current positions of a rigid body and looking for intersections with the volumes of other bodies."}),"\n",(0,i.jsx)(n.p,{children:"You can enable CCD for any PlayCanvas rigid body using the following script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var Ccd = pc.createScript('ccd');\n\nCcd.attributes.add('motionThreshold', {\n    type: 'number',\n    default: 1,\n    title: 'Motion Threshold',\n    description: 'Number of meters moved in one frame before CCD is enabled'\n});\n\nCcd.attributes.add('sweptSphereRadius', {\n    type: 'number',\n    default: 0.2,\n    title: 'Swept Sphere Radius',\n    description: 'This should be below the half extent of the collision volume. E.g For an object of dimensions 1 meter, try 0.2'\n});\n\n// initialize code called once per entity\nCcd.prototype.initialize = function() {\n    var body; // Type btRigidBody\n\n    body = this.entity.rigidbody.body;\n    body.setCcdMotionThreshold(this.motionThreshold);\n    body.setCcdSweptSphereRadius(this.sweptSphereRadius);\n\n    this.on('attr:motionThreshold', function(value, prev) {\n        body = this.entity.rigidbody.body;\n        body.setCcdMotionThreshold(value);\n    });\n    this.on('attr:sweptSphereRadius', function(value, prev) {\n        body = this.entity.rigidbody.body;\n        body.setCcdSweptSphereRadius(value);\n    });\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can find a project that implements CCD ",(0,i.jsx)(n.a,{href:"https://playcanvas.com/project/447023/overview/physics-with-ccd",children:"here"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"These are just two examples of using the ammo.js API directly. You can also use it to implement additional things like:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compound collision shapes"}),"\n",(0,i.jsx)(n.li,{children:"Soft body simulation"}),"\n",(0,i.jsx)(n.li,{children:"Cloth simulation"}),"\n",(0,i.jsx)(n.li,{children:"Vehicles"}),"\n"]})]})}function h(t={}){const{wrapper:n}={...(0,o.R)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(d,{...t})}):d(t)}},28453:(t,n,e)=>{e.d(n,{R:()=>a,x:()=>r});var i=e(96540);const o={},s=i.createContext(o);function a(t){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function r(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:a(t.components),i.createElement(s.Provider,{value:n},t.children)}}}]);