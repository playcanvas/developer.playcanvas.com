"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[3660],{39477:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var t=s(85893),a=s(11151);const i={title:"Loading Scenes",sidebar_position:3},c=void 0,o={id:"user-manual/scenes/loading-scenes",title:"Loading Scenes",description:"Introduction",source:"@site/docs/user-manual/scenes/loading-scenes.md",sourceDirName:"user-manual/scenes",slug:"/user-manual/scenes/loading-scenes",permalink:"/user-manual/scenes/loading-scenes",draft:!1,unlisted:!1,editUrl:"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/scenes/loading-scenes.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Loading Scenes",sidebar_position:3},sidebar:"userManualSidebar",previous:{title:"Sprite",permalink:"/user-manual/scenes/components/sprite"},next:{title:"Assets",permalink:"/user-manual/assets/"}},r={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Changing scenes completely",id:"changing-scenes-completely",level:2},{value:"Loading scenes additively",id:"loading-scenes-additively",level:2},{value:"Understanding how scenes work",id:"understanding-how-scenes-work",level:2},{value:"Destroying all children under application root node first",id:"destroying-all-children-under-application-root-node-first",level:3},{value:"Destroying the old scene root entity after the new scene is loaded",id:"destroying-the-old-scene-root-entity-after-the-new-scene-is-loaded",level:3},{value:"Managing assets in scenes",id:"managing-assets-in-scenes",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"This page will take you through loading scenes with code and also some different approaches of using scenes in projects."}),"\n",(0,t.jsx)(n.p,{children:"There are two main approaches in using scenes: changing scenes completely and additively loading scenes."}),"\n",(0,t.jsx)(n.h2,{id:"changing-scenes-completely",children:"Changing scenes completely"}),"\n",(0,t.jsx)(n.p,{children:"This is the most common approach that developers take where each scene is a self-contained part of the game. For example, one scene would be the title screen and then one scene per level."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://playcanvas.com/project/924351/overview/switch-full-scene-example",children:"Here is an example"})," where the user can move to and from the title screen to other levels."]}),"\n",(0,t.jsx)("div",{className:"iframe-container",children:(0,t.jsx)("iframe",{loading:"lazy",src:"https://playcanv.as/e/p/Q1gKd1ek/",title:"Switching Scenes Completely"})}),"\n",(0,t.jsxs)(n.p,{children:["This is done by simply calling ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.SceneRegistry.html#changeScene",children:(0,t.jsx)(n.code,{children:"SceneRegistry.changeScene"})})," with the name of the scene."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.app.scenes.changeScene('Some Scene Name');\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the scene data is not already loaded, this function will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Make the asynchronous network request for the new scene data."}),"\n",(0,t.jsx)(n.li,{children:"When the scene data is loaded, it will delete all child entities from the application root node (destroying the existing scene hierarchy)."}),"\n",(0,t.jsxs)(n.li,{children:["Call ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," which is now synchronous as the scene data is loaded."]}),"\n",(0,t.jsxs)(n.li,{children:["Call ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," which is now synchronous as the scene data is loaded."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If you want to know when the scene is loaded or if there are errors, you will need to provide a callback:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"this.app.scenes.changeScene('Some Scene Name', (err, loadedSceneRootEntity) {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To avoid the asynchronous network request for the new scene data at the point of calling ",(0,t.jsx)(n.code,{children:"changeScene"}),", you can call ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.SceneRegistry.html#loadSceneData",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneData"})})," ahead of time and ",(0,t.jsx)(n.code,{children:"changeScene"})," will become a synchronous call that immediately calls ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," and ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Common use cases would include knowing that the user would load level 2 when level 1 is completed. In this case, you can load the scene data for level 2 when the user is in level 1. When they complete level 1, they won't have to wait for data to be loaded and immediately enter level 2."}),"\n",(0,t.jsx)(n.h2,{id:"loading-scenes-additively",children:"Loading scenes additively"}),"\n",(0,t.jsx)(n.p,{children:"It is possible to load multiple scene hierarchies in an additive manner rather than completely switching scenes. The common use cases for this are to split up a large world so that it can be loaded over time rather than loading it all at once at the start."}),"\n",(0,t.jsx)(n.p,{children:"A variant of the above would be for each scene to represent a section of the world that is loaded and destroyed as the player moves around. The system would only load the nearest connected sections of the world and related assets while destroying and unloading assets for any section that is not needed. This would help with managing resources such as memory and VRAM."}),"\n",(0,t.jsx)(n.p,{children:"Sometimes developers use this approach to ensure that certain code and entities are created before the actual game loads and have them globally accessible throughout the game session."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://playcanvas.com/project/685077/overview/additive-loading-scenes",children:"Below is a simplified example"})," of additively loading scenes where the UI in the top left is the 'main' scene and different scene hierarchies are loaded/destroyed."]}),"\n",(0,t.jsx)("div",{className:"iframe-container",children:(0,t.jsx)("iframe",{loading:"lazy",src:"https://playcanv.as/e/p/cjBInud1/",title:"Additively Loading Scenes"})}),"\n",(0,t.jsx)(n.p,{children:"Please note that multiple instances of the scene hierarchy cannot be loaded at once. This is due to the entities having their unique GUIDs assigned in the Editor. When multiple instances of the same scene hierarchy are attempted to be loaded at once, there's a clash of GUIDs which are meant to be unique per entity."}),"\n",(0,t.jsxs)(n.p,{children:["If you need multiple instances of an entity hierarchy, please use ",(0,t.jsx)(n.a,{href:"/user-manual/templates/",children:"Templates"})," instead as unique GUIDs are given on instantiation of the template instance."]}),"\n",(0,t.jsx)(n.h2,{id:"understanding-how-scenes-work",children:"Understanding how scenes work"}),"\n",(0,t.jsx)(n.p,{children:"To use scenes effectively, it is important to understand how they are loaded when used in a project. This section goes into detail about how scenes are structured and loaded."}),"\n",(0,t.jsxs)(n.p,{children:["Scenes are separate from ",(0,t.jsx)(n.a,{href:"/user-manual/assets/",children:"assets"})," and have different properties and APIs to load them."]}),"\n",(0,t.jsxs)(n.p,{children:["Scenes are represented by ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.SceneRegistryItem.html",children:"Scene Registry Items"})," that are stored in the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.SceneRegistry.html",children:"Scene Registry"})," which can be accessed through ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.Application.html#scenes",children:"Application"})," object. Through the Scene Registry, you can find the Scene Registry Item by the name of the scene in the Editor and use it to load the scene hierarchy or settings."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.Application.html#root",children:"application root node"})," is not the scene hierarchy root entity that is named 'Root' by default that you see in the scene with the Editor. The scene hierarchy root entity will be a child of the application root node."]})}),"\n",(0,t.jsx)(n.p,{children:"There are two APIs to load the scene hierarchy and settings:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.SceneRegistry.html#loadSceneHierarchy",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneHierarchy"})})," - Loads a scene hierarchy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.SceneRegistry.html#loadSceneSettings",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneSettings"})})," - Loads settings from a scene"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here is a code example to load the scene hierarchy or settings:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Find the Scene Registry Item by the name of the scene\nvar sceneItem = this.app.scenes.find('Some Scene Name');\n\n// Load the scene hierarchy with a callback when it has finished\nthis.app.scenes.loadSceneHierarchy(sceneItem, function (err, loadedSceneRootEntity) {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n    }\n});\n\n// Load the scene settings with a callback when it has finished\nthis.app.scenes.loadSceneSettings(sceneItem, function (err) {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene settings has successfully been loaded\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," and ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," have similar behavior in how they get the data needed to load the hierarchy or settings."]}),"\n",(0,t.jsx)(n.p,{children:"When the function is called, it performs an asynchronous network request to the server for the scene data. This means that there will be a delay (depending on network speed, the network connection and size of the scene) between the request to load the scene and the browser completing the network request where the application is still updating."}),"\n",(0,t.jsx)(n.p,{children:"Once the network request has been completed, the engine will do the following:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Creates the entities and components from the loaded scene and adds the hierarchy to the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.Application.html#root",children:"application root node"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Calls ",(0,t.jsx)(n.code,{children:"initialize"})," and ",(0,t.jsx)(n.code,{children:"postInitialize"})," functions on the ScriptTypes in the loaded scene."]}),"\n",(0,t.jsxs)(n.li,{children:["Calls the callback that was passed into the ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," function."]}),"\n",(0,t.jsxs)(n.li,{children:["(Optional) In the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/modules/Engine.html#LoadHierarchyCallback",children:"callback"}),", the entity that represents the loaded scene root is passed as a parameter. This can be modified or reparented depending on your needs. In the ",(0,t.jsx)(n.a,{href:"#loading-scenes-additively",children:"Loading Scenes Additively"})," example, it reparents to scene root to another entity in the current scene to make it easier to manage."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"loadSceneSettings"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Applies the loaded scene settings to the application."}),"\n",(0,t.jsxs)(n.li,{children:["Calls the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/modules/Engine.html#LoadSettingsCallback",children:"callback"})," that was passed into the ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," function."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["By default, ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," will always load additively and it's up to the developer to remove/destroy the existing loaded scene to change scenes completely."]}),"\n",(0,t.jsx)(n.p,{children:"There are several ways to approach this with pros and cons:"}),"\n",(0,t.jsx)(n.h3,{id:"destroying-all-children-under-application-root-node-first",children:"Destroying all children under application root node first"}),"\n",(0,t.jsx)(n.p,{children:"This approach has discrete steps that make it easier to manage where the currently loaded scene is destroyed before loading and creation of the new scene."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Find the Scene Registry Item by the name of the scene\nvar sceneItem = this.app.scenes.find('Some Scene Name');\n\n// Destroy all children under application root to remove the currently loaded scene hierarchy\nvar rootChildren = this.app.root.children;\nwhile(rootChildren.length > 0) {\n    rootChildren[0].destroy();\n}\n\n// Load the scene hierarchy with a callback when it has finished\nthis.app.scenes.loadSceneHierarchy(sceneItem, function (err, loadedSceneRootEntity) {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, as mentioned above, there is a delay between calling ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," and the scene data actually being loaded. This means that there will be a few frames where the application will be rendering a blank screen while its waiting for the network request to complete which brings us to the alternative."]}),"\n",(0,t.jsx)(n.h3,{id:"destroying-the-old-scene-root-entity-after-the-new-scene-is-loaded",children:"Destroying the old scene root entity after the new scene is loaded"}),"\n",(0,t.jsx)(n.p,{children:"This would mean that the old scene hierarchy will be destroyed in the callback after the new scene hierarchy has been added to hierarchy which ensures that the old scene would be present while the scene data is loaded from network."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// Find the Scene Registry Item by the name of the scene\nvar sceneItem = this.app.scenes.find('Some Scene Name');\n\n// Assume the old scene hierarchy's root entity is named 'Root' which is the default name\nvar oldSceneRootEntity = this.app.root.findByName('Root');\n\n// Load the scene hierarchy with a callback when it has finished\nthis.app.scenes.loadSceneHierarchy(sceneItem, function (err, loadedSceneRootEntity) {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n        oldSceneRootEntity.destroy();\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, the old scene will be present in the hierarchy while the new scene's scriptTypes call ",(0,t.jsx)(n.code,{children:"initialize"})," and ",(0,t.jsx)(n.code,{children:"postInitialize"}),". This can cause issues if there is some dependency or assumptions in the scripts that it's the only scene hierarchy that is loaded. Examples would be searching for an entity by name in ",(0,t.jsx)(n.code,{children:"initialize"})," and there is also an entity with the same name in the old scene hierarchy. The script would then have a reference to the old scene hierarchy's entity instead of the new scene's which will cause unexpected behavior once the old scene's hierarchy is destroyed."]}),"\n",(0,t.jsxs)(n.p,{children:["To help mitigate these potential issues, we have an API that allows the separation of loading the scene data from the creation of the scene hierarchy in the scene, ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.SceneRegistry.html#loadSceneData",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneData"})}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"managing-assets-in-scenes",children:"Managing assets in scenes"}),"\n",(0,t.jsx)(n.p,{children:"A common question with scenes is if the assets used in the scene will be loaded as part of the scene load. With PlayCanvas, the assets and scenes are separate and will need to be loaded separately which gives the developer a large degree of flexibility."}),"\n",(0,t.jsx)(n.p,{children:"The recommended practice is to tag all the assets with the scene name needed in the scene and when it comes to load the scene, load the assets first and when all the assets are loaded, start loading the scene."}),"\n",(0,t.jsxs)(n.p,{children:["More information about asset tags and asset loading can be found on ",(0,t.jsx)(n.a,{href:"/user-manual/assets/preloading-and-streaming/#asset-tags",children:"this page"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://playcanvas.com/project/926754/overview/asset-loading-for-scenes-example",children:"example project"})," below loads the assets when loading the scene and unloads when returning the main menu."]}),"\n",(0,t.jsx)("div",{className:"iframe-container",children:(0,t.jsx)("iframe",{loading:"lazy",src:"https://playcanv.as/e/p/SBTfOAeM/",title:"Loading scenes and assets"})})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>c});var t=s(67294);const a={},i=t.createContext(a);function c(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);