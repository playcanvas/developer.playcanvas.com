"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[471],{37553:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=t(85893),i=t(11151);const s={title:"Batching",sidebar_position:4},r=void 0,o={id:"user-manual/graphics/advanced-rendering/batching",title:"Batching",description:"Batching is the process of combining multiple mesh instances together into a single mesh instance, so that they can all be rendered in a single GPU draw call. PlayCanvas provides a handy feature on the Model, Sprite and Element components that lets you assign these components to batch groups which give the engine hints on how to combine meshes to reduce the overall draw call count.",source:"@site/docs/user-manual/graphics/advanced-rendering/batching.md",sourceDirName:"user-manual/graphics/advanced-rendering",slug:"/user-manual/graphics/advanced-rendering/batching",permalink:"/user-manual/graphics/advanced-rendering/batching",draft:!1,unlisted:!1,editUrl:"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/advanced-rendering/batching.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Batching",sidebar_position:4},sidebar:"userManualSidebar",previous:{title:"Advanced Rendering",permalink:"/user-manual/graphics/advanced-rendering/"},next:{title:"Hardware Instancing",permalink:"/user-manual/graphics/advanced-rendering/hardware-instancing"}},h={},c=[{value:"Creating Batch Groups",id:"creating-batch-groups",level:2},{value:"Batch Group Properties",id:"batch-group-properties",level:3},{value:"Adding a component to a Batch Group",id:"adding-a-component-to-a-batch-group",level:2},{value:"Rules for combining mesh instances",id:"rules-for-combining-mesh-instances",level:2},{value:"Trigger re-batching",id:"trigger-re-batching",level:2},{value:"Example - Batching a static environment",id:"example---batching-a-static-environment",level:2},{value:"Terminology",id:"terminology",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Batching is the process of combining multiple mesh instances together into a single mesh instance, so that they can all be rendered in a single GPU draw call. PlayCanvas provides a handy feature on the ",(0,a.jsx)(n.a,{href:"/user-manual/scenes/components/model",children:"Model"}),", ",(0,a.jsx)(n.a,{href:"/user-manual/scenes/components/sprite",children:"Sprite"})," and ",(0,a.jsx)(n.a,{href:"/user-manual/scenes/components/element",children:"Element"})," components that lets you assign these components to batch groups which give the engine hints on how to combine meshes to reduce the overall draw call count."]}),"\n",(0,a.jsx)(n.p,{children:"There are a variety of rules which the engine will apply to see if mesh instances are able to be combined. The primary rule is that all mesh instances must share the same material."}),"\n",(0,a.jsx)(n.p,{children:"Common batching use cases are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Combine together static geometry -- e.g. environments -- into a single mesh instance or multiple large instances to reduce draw calls, but still support camera culling."}),"\n",(0,a.jsx)(n.li,{children:"Combine together dynamic geometry -- e.g. a set of moving objects -- into a single mesh instance with dynamic properties that are applied on the GPU."}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["The use of batching is currently not compatible with ",(0,a.jsx)(n.a,{href:"/user-manual/graphics/lighting/runtime-lightmaps/",children:"runtime lightmaps"})," due to each lightmapped object requiring its own unique lightmap texture."]})}),"\n",(0,a.jsx)(n.h2,{id:"creating-batch-groups",children:"Creating Batch Groups"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"/images/user-manual/optimization/batching/batch-groups.jpg",alt:"Creating Batch Groups"})}),"\n",(0,a.jsxs)(n.p,{children:["Batch Groups can be created from the Batch Groups section of the ",(0,a.jsx)(n.a,{href:"/user-manual/scenes/settings#batch-groups",children:"scene settings panel"}),". Each batch group has a number of properties that are used to give the engine hints about how to create batches from this batch group."]}),"\n",(0,a.jsx)(n.h3,{id:"batch-group-properties",children:"Batch Group Properties"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Name"}),": Used to differentiate different batch groups, ideally it would describe the kinds of objects that this batch group will have. This name is available at runtime to retrieve the group."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic"}),": If enabled then objects inside the batch group can still move/rotate/scale. You can use this for objects that are similar to each other and use the same materials e.g. bullets. Static groups use less runtime resources so you should disable Dynamic if the contents of batch group will not move."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Max AABB size"}),": The maximum size of any one side of the bounding box that contains all objects in the batch group at the time when the batches are created. If the set of meshes are larger than the maximum size it will create multiple batches to be rendered. A larger bounding box will render in less draw calls, but will work less well with camera culling."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"adding-a-component-to-a-batch-group",children:"Adding a component to a Batch Group"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"/images/user-manual/optimization/batching/model-component.jpg",alt:"Selecting Batch Groups"})}),"\n",(0,a.jsx)(n.p,{children:"The Model component has a Batch Group property to assign a model into a batch group."}),"\n",(0,a.jsx)(n.h2,{id:"rules-for-combining-mesh-instances",children:"Rules for combining mesh instances"}),"\n",(0,a.jsx)(n.p,{children:"The rules for whether the engine can combine mesh instances are fairly complicated but a good summary is that all mesh instances that belong to a single batch must obey the following:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Have the same Batch Group ID"}),"\n",(0,a.jsx)(n.li,{children:"Have the same material"}),"\n",(0,a.jsx)(n.li,{children:"Have the same shader parameters"}),"\n",(0,a.jsx)(n.li,{children:"Be within a bounding box with no side larger than the Max AABB Size"}),"\n",(0,a.jsx)(n.li,{children:"Be in the same layer"}),"\n",(0,a.jsx)(n.li,{children:"Each batch has a maximum vertex count of 65535"}),"\n",(0,a.jsx)(n.li,{children:"For dynamic batches there is a maximum number of movable mesh instances. This hardware dependent but has a maximum of 1024."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If a batch group contains components or mesh instances that do not obey all of the rules the batch group will produce multiple batches such that each individual batch contains mesh instance that follow all the rules."}),"\n",(0,a.jsx)(n.h2,{id:"trigger-re-batching",children:"Trigger re-batching"}),"\n",(0,a.jsx)(n.p,{children:"Based on Batch Groups the engine creates an optimized version of mesh instances. Further changes to many properties of the original mesh instances are not reflected in the optimized versions. To allow for good performance by using batching, while still allowing some further updates, you can request the engine to rebatch individual Batch Groups after you make changes to the original mesh instances. This is often useful with User Interface element components, where you might want to set up batching, but still need to do infrequent updates. Note that re-batching a group is a potentially expensive operation. In many cases, the impact of rebatching can be minimized by separating elements that need updating to separate Batch Group."}),"\n",(0,a.jsxs)(n.p,{children:["Here is an example of a simple script. The script updates ",(0,a.jsx)(n.code,{children:"textureAsset"})," on an element, and marks the Batch Group as dirty."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// change textureAsset on element\nelement.textureAsset = this.hoverAsset;\n\n// if this element has Batch Group set, mark it dirty to rebuild the group in the next frame\nif (element.batchGroupId)\n    this.app.batcher.markGroupDirty(element.batchGroupId);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"example---batching-a-static-environment",children:"Example - Batching a static environment"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"/images/user-manual/optimization/batching/western-scene.jpg",alt:"Western Scene"})}),"\n",(0,a.jsx)(n.p,{children:"In this scene we have created a static environment from 7 separate model files, some of which are repeated in the scene. For example, the road tile is used to in 50 entities to create the long road through the center of the scene."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"/images/user-manual/optimization/batching/western-animation-all.gif",alt:"Western Animation"})}),"\n",(0,a.jsx)(n.p,{children:"You can see in the animation each draw call as it is made. In this environment the engine makes over 50 draw calls to draw each of the models individually. However, apart from the ground, all of these models use the same material and so they can be combined into batch groups."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"/images/user-manual/optimization/batching/western-animation.gif",alt:"Western Animation Batched"})}),"\n",(0,a.jsx)(n.p,{children:"In this animation we have created 4 batch groups for the buildings, the cacti, the road and the ground. Notice, that the road and the ground are not combined into single draw calls because the meshes are larger than the Max AABB Size defined on the batch group."}),"\n",(0,a.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch Group"})," - A named group, created in the Editor, that defines some hints on how mesh instances should be combined. Components are assigned to a batch group"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch"})," - An engine object created at runtime which is the set of mesh instances that are rendered in a single draw call. A batch group may result in multiple batches depending on the properties of the mesh instances that are added to the batch group."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch Manager"})," - The programmatic interface for creating and updating batches at runtime. See ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/classes/Engine.BatchManager.html",children:"API documentation"}),"."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var a=t(67294);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);